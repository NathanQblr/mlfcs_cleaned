"""Module giving classical fitting function of FCS autocorrelogram"""

import numpy as np
import scipy.optimize
from signal_tools import g_mb_theory, g_fbm_theory

def return_tau(K):
    efin = 0.15
    step = 1e-5

    s_0 = np.log(step)/np.log(10)
    s_fin = (np.log(efin))/np.log(10)
    tau = np.linspace(s_0,s_fin,K+1)
    for i in range(K+1):
        tau[i] = pow(10,tau[i])#/self.step
    return tau

def init_fitterD(tau, line):
    """This is a function that initializes a fitter for a given set of parameters and a signal.
    The fitter is used to minimize the loss function by adjusting the parameters to fit the signal.
    The loss function is defined as the squared difference between the signal and the theoretical fit generated by the given parameters.
    The function returns the loss function that can be used for optimization. The nan_to_num function is used to replace any NaN values with zero.

    Args:
        step (float): size in second of the bin window
        tau (int): points of comparison
        omega_x (int): illumination width
        omega (int): illumination depth
        signal (np.array): experimental autocorrelogram

    Returns:
        loss (function): loss function to optimize
    """
    omega_x = line['omega_x']*1e-3
    omega = line['omega']*1e-3
    signal = line['G']
    step = 1e-5
    signal = np.nan_to_num(signal, nan=0.0)
    signal = signal/signal[:5].mean()
    final = np.sum((signal != 0))
    def loss(var):
        x_fit = g_mb_theory(tau[:final], omega_x, omega, var)
        return (np.linalg.norm((signal[:final] - x_fit)) ** 2 / final)
    return loss

def init_fitteralpha(tau, line):
    """This is a function that initializes a fitter for a given set of parameters and a signal.
    The fitter is used to minimize the loss function by adjusting the parameters to fit the signal.
    The loss function is defined as the squared difference between the signal and the theoretical fit generated by the given parameters.
    The function returns the loss function that can be used for optimization. The nan_to_num function is used to replace any NaN values with zero.

    Args:
        step (float): size in second of the bin window
        tau (int): points of comparison
        omega_x (int): illumination width
        omega (int): illumination depth
        signal (np.array): experimental autocorrelogram

    Returns:
        loss (function): loss function to optimize
    """
    omega_x = line['omega_x']*1e-3
    omega = line['omega']*1e-3
    signal = line['G']
    step = 1e-5
    signal = np.nan_to_num(signal, nan=0.0)
    final = np.sum((signal != 0))

    def loss(var):
        x_fit = g_fbm_theory(tau[:final], omega_x, omega, var)
        return (np.linalg.norm((signal[:final] - x_fit)) ** 2 / final)
    return loss

def classical_fitD(tau, line):
    """This is a function that fit for a given set of parameters a signal.
    The fitter is used to minimize the loss function by adjusting the parameters to fit the signal.
    The loss function is defined as the squared difference between the signal and the theoretical fit generated by the given parameters.
    The function returns the loss function that can be used for optimization. The nan_to_num function is used to replace any NaN values with zero.

    Args:
        step (float): size in second of the bin window
        tau (int): points of comparison
        omega_x (int): illumination width
        omega (int): illumination depth
        signal (np.array): experimental autocorrelogram

    Returns:
        (float) optimal value of diffusion coefficient D
    """
    loss = init_fitterD(tau, line)
    bnds = scipy.optimize.Bounds(lb=(0.5, 0.01), ub=(10.0, 20.0), keep_feasible=False)
    success = 0
    n_try = 0
    while (success == 0 and n_try < 3):
        var0 = (2.0, 2.0 * np.random.rand() + 0.01)
        res = scipy.optimize.minimize(loss, var0, bounds=bnds)
        if res.success :
            success = 1
        n_try += 1
    if success == 1:
        return res.x[1]
    else:
        return np.NaN

def classical_fitalpha(tau, line):
    """This is a function that fit for a given set of parameters a signal.
    The fitter is used to minimize the loss function by adjusting the parameters to fit the signal.
    The loss function is defined as the squared difference between the signal and the theoretical fit generated by the given parameters.
    The function returns the loss function that can be used for optimization. The nan_to_num function is used to replace any NaN values with zero.

    Args:
        step (float): size in second of the bin window
        tau (int): points of comparison
        omega_x (int): illumination width
        omega (int): illumination depth
        signal (np.array): experimental autocorrelogram

    Returns:
        (float) optimal value of diffusion coefficient D
    """
    loss = init_fitteralpha(tau, line)
    bnds = scipy.optimize.Bounds(lb=(0.5, 0.01, 0.01), ub=(10.0,20.0,1.9), keep_feasible=False)
    success = 0
    n_try = 0
    while (success == 0 and n_try < 3):
        var0 = (2.0, 2.0*np.random.rand()+0.01,0.9)
        res = scipy.optimize.least_squares(loss,var0,bounds=bnds)
        if res.success :
            success = 1
        n_try += 1
    if success == 1:
        return res.x[1],res.x[2]
    else:
        return np.NaN,np.NaN


